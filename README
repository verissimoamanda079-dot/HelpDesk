# Gestor de Prioridade

Sistema de triagem e classificação automática de tickets de suporte com cálculo de SLA baseado em regras de negócio.

## Visão Geral

O Gestor de Prioridade é uma aplicação web desenvolvida para automatizar o processo de classificação de tickets de suporte em um sistema de HelpDesk. O sistema analisa a descrição do ticket e o tipo de cliente para calcular automaticamente a urgência (SLA) baseado em palavras-chave pré-definidas.

### Funcionalidades Principais

- Criação de tickets com título, descrição e tipo de cliente
- Cálculo automático de urgência baseado em matriz de decisão
- Visualização de tickets em duas filas: Pendente e Classificada
- Processamento em lote de tickets pendentes
- Interface responsiva e intuitiva

## Arquitetura

```
┌─────────────┐      ┌─────────────┐      ┌──────────────┐
│   Frontend  │─────▶│   Backend   │─────▶│  PostgreSQL  │
│   (React)   │◀─────│  (Node.js)  │◀─────│              │
└─────────────┘      └─────────────┘      └──────────────┘
```

- **Frontend:** React 18 com Tailwind CSS
- **Backend:** Node.js 18 + Express.js
- **Banco de Dados:** PostgreSQL 15
- **Containerização:** Docker + Docker Compose

## Pré-requisitos

- Docker 20.10 ou superior
- Docker Compose 2.0 ou superior
- Git

Para desenvolvimento local sem Docker:
- Node.js 18 ou superior
- PostgreSQL 15 ou superior
- npm ou yarn

## Instalação

### Com Docker (Recomendado)

```bash
git clone https://github.com/seu-usuario/gestor-prioridade.git
cd gestor-prioridade

docker-compose up -d
```

O sistema estará disponível em:
- Frontend: http://localhost:3000
- Backend API: http://localhost:5000
- PostgreSQL: localhost:5432

### Sem Docker

#### Backend

```bash
cd backend
npm install

cp .env.example .env

npm run migrate

npm run dev
```

#### Frontend

```bash
cd frontend
npm install

npm start
```

## Configuração

### Variáveis de Ambiente

Copie o arquivo `.env.example` para `.env` e configure:

```bash
PORT=5000
NODE_ENV=development

DATABASE_HOST=localhost
DATABASE_PORT=5432
DATABASE_NAME=gestor_prioridade
DATABASE_USER=admin
DATABASE_PASSWORD=admin123
```

## Uso

### Criar Ticket

1. Acesse http://localhost:3000
2. Preencha o formulário:
   - Título: descrição breve do problema
   - Descrição: detalhes do problema
   - Tipo de Cliente: GRATUITO, BASICO ou PREMIUM
3. Clique em "Criar Ticket"
4. O ticket aparecerá na fila "Pendente"

### Processar Fila

1. Após criar tickets, clique em "Processar Fila Pendente"
2. O sistema calculará a urgência de cada ticket
3. Tickets processados aparecerão na fila "Classificada" com a urgência calculada

## Regras de Negócio

### Palavras-chave por Nível de Impacto

**Críticas:** parado, offline, não funciona, down, fora do ar
**Altas:** erro, bug, lento, lentidão, falha de acesso
**Médias:** dúvida, como fazer, ajuda, orientação

### Matriz de Decisão de Urgência

| Tipo Cliente | Impacto Crítico | Impacto Alto | Impacto Médio/Nenhum |
|--------------|-----------------|--------------|----------------------|
| PREMIUM      | CRITICA         | ALTA         | MEDIA                |
| BASICO       | ALTA            | MEDIA        | BAIXA                |
| GRATUITO     | MEDIA           | BAIXA        | BAIXA                |

### Regra de Prevalência

Quando múltiplas palavras-chave de diferentes níveis são detectadas na descrição, a palavra de maior impacto prevalece.

**Exemplo:**
- Descrição: "Tenho dúvida sobre o sistema que não funciona"
- Detecta: "dúvida" (média) e "não funciona" (crítica)
- Prevalece: nível crítico
- Resultado para cliente PREMIUM: urgência CRÍTICA

## API

### Endpoints

#### POST /api/tickets
Cria um novo ticket

**Request:**
```json
{
  "titulo": "Sistema fora do ar",
  "descricao": "O sistema está completamente parado",
  "tipo_cliente": "PREMIUM"
}
```

**Response (201):**
```json
{
  "message": "Ticket criado com sucesso",
  "ticket": {
    "id": 1,
    "titulo": "Sistema fora do ar",
    "descricao": "O sistema está completamente parado",
    "tipo_cliente": "PREMIUM",
    "status": "PENDENTE",
    "urgencia_calculada": null,
    "created_at": "2025-11-02T10:00:00.000Z"
  }
}
```

#### GET /api/tickets
Lista todos os tickets

**Query params:**
- `status` (opcional): PENDENTE | CLASSIFICADO

**Response (200):**
```json
{
  "total": 5,
  "tickets": [...]
}
```

#### GET /api/tickets/:id
Busca ticket por ID

**Response (200):**
```json
{
  "ticket": {...}
}
```

#### POST /api/tickets/processar
Processa fila de tickets pendentes

**Response (200):**
```json
{
  "message": "3 ticket(s) processado(s) com sucesso",
  "processados": 3,
  "tickets": [...]
}
```

## Testes

### Executar Testes Unitários

```bash
cd backend
npm test
```

Cobertura: 87% (42 testes)

### Executar Testes de Integração

```bash
cd backend
npm run test:integration
```

Cobertura: 78% (18 testes)

### Executar Testes E2E

```bash
cd tests-e2e
npm install
npx playwright install
npx playwright test
```

Modo interativo:
```bash
npx playwright test --ui
```

Modo debug:
```bash
npx playwright test --debug
```

### Cobertura Total

- Testes Unitários: 42 testes (87% cobertura)
- Testes de Integração: 18 testes (78% cobertura)
- Testes E2E: 15 testes (90% cobertura)
- **Cobertura Total: 83%**

## Estrutura do Projeto

```
gestor-prioridade/
├── backend/              # Servidor Node.js + Express
│   ├── src/
│   │   ├── config/      # Configurações e migrations
│   │   ├── models/      # Modelos de dados
│   │   ├── services/    # Lógica de negócio
│   │   ├── controllers/ # Controladores das rotas
│   │   ├── routes/      # Definição de rotas
│   │   └── middlewares/ # Middlewares
│   └── tests/           # Testes unitários e integração
├── frontend/             # Interface React
│   ├── src/
│   │   ├── components/  # Componentes React
│   │   └── services/    # Cliente HTTP
│   └── public/          # Arquivos estáticos
├── tests-e2e/           # Testes End-to-End (Playwright)
└── docs/                # Documentação
    ├── features/        # Especificações Gherkin
    └── *.md            # Planos e relatórios
```

## Documentação

### Especificações Gherkin

As especificações de comportamento estão em `docs/features/`:
- `criar-ticket.feature` - Criação de tickets
- `processar-fila.feature` - Processamento de fila
- `calcular-urgencia.feature` - Cálculo de urgência (SLA)

### Plano de Testes

Documento completo em `docs/PLANO_DE_TESTES.md`:
- Estratégia de testes por sprint
- Categorias de teste (caixa preta/branca)
- Cenários detalhados
- Métricas e critérios de aceitação

### Bugs Identificados

Relatório em `docs/BUGS_ENCONTRADOS.md`:
- BUG-001: Validação de título vazio no backend
- BUG-002: Contador não atualiza imediatamente
- BUG-003: Mensagens não desaparecem automaticamente

### Requisitos Não Atendidos

Documento em `docs/REQUISITOS_NAO_ATENDIDOS.md`:
- RQNF10: Relatório SonarQube completo (30% atendido)
- RQNF7: Testes de integração completos (70% atendido)
- Justificativas e soluções propostas

## Melhorias Identificadas

### Curto Prazo (Sprint 1-2)

1. Implementar validação com Joi/Yup no backend
2. Adicionar sanitização de inputs (prevenir XSS)
3. Refatorar método calcularUrgencia para reduzir complexidade
4. Implementar rate limiting
5. Adicionar logs estruturados

### Médio Prazo (Sprint 3-4)

6. Implementar autenticação JWT
7. Adicionar cache com Redis
8. Implementar paginação nas listagens
9. WebSocket para notificações real-time
10. Dashboard com métricas e gráficos

### Longo Prazo (Backlog)

11. Separar em microserviços
12. Implementar event sourcing
13. Sistema de audit log
14. Exportação de relatórios (PDF/Excel)
15. Busca e filtros avançados

## Decisões Técnicas

### Por que Node.js?
- Ecossistema maduro e grande comunidade
- Performance adequada para aplicações CRUD
- Facilita desenvolvimento full-stack (JavaScript no frontend e backend)
- Excelente suporte para APIs REST

### Por que PostgreSQL?
- ACID compliant (transações confiáveis)
- Constraints no banco garantem integridade
- Performance superior em queries complexas
- Gratuito e open source

### Por que React?
- Componentização facilita manutenção
- Virtual DOM oferece performance
- Grande ecossistema de bibliotecas
- Curva de aprendizado moderada

### Por que Docker?
- Ambiente consistente entre desenvolvimento e produção
- Facilita onboarding de novos desenvolvedores
- Isola dependências
- Simplifica deployment

## Contribuindo

### Convenções de Commit

```
feat: adiciona nova funcionalidade
fix: corrige bug
test: adiciona ou modifica testes
docs: atualiza documentação
refactor: refatora código
style: formatação
chore: tarefas de manutenção
```

### Estratégia de Branches

```
main (produção)
├── develop (desenvolvimento)
│   ├── feature/nome-da-feature
│   └── bugfix/nome-do-bug
└── hotfix/correcao-critica
```

### Pull Requests

1. Crie uma branch a partir de `develop`
2. Implemente as mudanças
3. Adicione testes
4. Atualize documentação se necessário
5. Abra PR para `develop`
6. Aguarde revisão de código

## Troubleshooting

### Erro ao conectar no banco

```bash
docker-compose logs postgres
docker-compose restart postgres
```

### Porta já em uso

```bash
lsof -ti:5000 | xargs kill
lsof -ti:3000 | xargs kill
```

### Migrations não executam

```bash
docker-compose exec backend npm run migrate
```

### Limpar banco de dados

```bash
docker-compose exec postgres psql -U admin -d gestor_prioridade -c "DELETE FROM tickets;"
```

### Rebuild dos containers

```bash
docker-compose down
docker-compose build --no-cache
docker-compose up -d
```

## Performance

### Métricas Atuais

- Tempo de resposta médio da API: 45ms
- Tempo de processamento de 100 tickets: 2.3s
- Tamanho do bundle frontend: 180KB (gzipped)
- Queries ao banco: média de 15ms

### Otimizações Implementadas

- Índices no banco de dados (status, tipo_cliente)
- Pool de conexões PostgreSQL configurado
- Queries SQL otimizadas (prepared statements)
- Componentes React memoizados

## Segurança

### Implementado

- Helmet.js (headers de segurança HTTP)
- CORS configurado
- Validação de inputs
- Prepared statements (prevenção SQL injection)
- Error handling sem exposição de stack traces

### A Implementar

- Autenticação JWT
- Rate limiting
- Sanitização avançada de inputs
- Logs de auditoria
- HTTPS em produção

## Licença

MIT License

Copyright (c) 2025

## Autor

Desenvolvido como parte do desafio técnico de avaliação para vaga de desenvolvedor.

## Contato

Para dúvidas ou sugestões:
- Issues: https://github.com/seu-usuario/gestor-prioridade/issues
- Email: seu-email@example.com

## Agradecimentos

- Equipe de revisão técnica
- Comunidade open source
- Documentação oficial do Express, React e PostgreSQL
